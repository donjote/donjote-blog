---
title: 微服务架构的优势与不足
categories: 微服务
tags: [微服务,架构,单体应用]
---
 >我们现在处于一个由云驱动的应用开发和IT系统管理的革命大潮中。快速、灵活、便宜并且可以大规模扩展的基础设施，具有充分的自服务和现收现付计费方式，提高着运营效率并加快了各行业的价值实现进程。容器的出现，及其快速发展的初创企业、标准化的应用包装、隔离模型，进一步提升了效率和灵活性。


 >然而，许多公司发现在应用的高可用性、可扩展性和敏捷性方面仍然面临诸多挑战。商业竞争的压力需要应用不断地演进，增加新的特性和功能，同时保持24x7可用。例如，现在我们已经无法接受银行网站的维护窗口了，然而几年之前这还是一种常态。同样的，一个电子商务网站即使是短时间的崩溃，也将会使客户转向在那个时刻能够给他们提供服务的其他竞争对手。未能满足这些需求可能意味着保持相关性与失去业务之间的区别。

## 单体应用模型

>先来看看传统的web开发方式，通过对比比较容易理解什么是微服务架构。和微服务架构相对应的，这种方式一般被称为Monolithic(单体应用模型)（比较难传神的翻译）。所有的功能打包在一个 WAR包里，基本没有外部依赖（除了容器），部署在一个JEE容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI等所有逻辑。
![单体应用模型](1.png)
Monolithic比较适合小项目，优点是：
+ 开发简单直接，集中式管理
+ 基本不会重复开发
+ 功能都在本地，没有分布式的管理开销和调用开销

它的缺点也非常明显，特别对于互联网公司来说（不一一列举了）：
>+ 开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断
+ 代码维护难：代码功能耦合在一起，新人不知道何从下手
+ 部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长
+ 稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉
+ 扩展性不够：无法满足高并发情况下的业务需求
+ 敏捷开发和部署举步维艰，其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。
+ 修正bug和正确的添加新功能变的非常困难，并且很耗时。
+ 团队士气也会走下坡路。如果代码难于理解，就不可能被正确的修改。最终会走向巨大的、不可理解的泥潭。
+ 复杂而巨大的单体式应用也不利于持续性开发。今天，SaaS应用常态就是每天会改变很多次，而这对于单体式应用模式非常困难。另外，这种变化带来的影响并没有很好的被理解，所以不得不做很多手工测试。那么接下来，持续部署也会很艰难。
+ 单体式应用在不同模块发生资源冲突时，扩展将会非常困难。
+ 单体式应用另外一个问题是可靠性。因为所有模块都运行在一个进程中，任何一个模块中的一个bug，比如内存泄露，将会有可能弄垮整个进程。除此之外，因为所有应用实例都是唯一的，这个bug将会影响到整个应用的可靠性。
+ 单体式应用使得采用新架构和语言非常困难。比如，设想你有两百万行采用XYZ框架写的代码。如果想改成ABC框架，无论是时间还是成本都是非常昂贵的，即使ABC框架更好。因此，这是一个无法逾越的鸿沟。你不得不在最初选择面前低头。

总结一下：一开始你有一个很成功的关键业务应用，后来就变成了一个巨大的，无法理解的怪物。因为采用过时的，效率低的技术，使得雇佣有潜力的开发者很困难。应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成。

## 微服务架构
>虽然对于一些简单的、规模有限的应用而言，单体架构仍然是有意义的。微服务是应用开发和部署的一个不同的方法。它非常适合许多现代的云应用对于敏捷性、扩展规模和可靠性的要求。一个微服务应用被分解成独立的部件，被称为“微服务”。“微服务”协同工作，以便提供应用的整体功能。“微服务”这一术语强调一个事实，那就是应用应该是由足够小的服务所组成，以便真正体现独立性，使得每个微服务实现单一的功能。此外，每个微服务都有明确的合同（API合同）——通常是RESTful 的——以便其他微服务能够与之进行交流和分享数据。微服务也必须能够彼此独立地进行版本更新。这种松耦合正是对一个应用实现快速而可靠地演化的支撑。下图显示了一个单体应用是如何被分解为不同的微服务的。
![微服务架构](2.png)

### 微服务的具体特征:
>+ 分布式服务组成的系统
+ 按照业务而不是技术来划分组织
+ 做有生命的产品而不是项目
+ 强服务和弱通信
+ 自动化运维（DevOps）
+ 容错
+ 快速演化

### 微服务的优点：
>+ 每个服务足够内聚，足够小，代码容易理解、开发效率提高
+ 服务之间可以独立部署，微服务架构让持续部署成为可能；
+ 每个服务可以各自进行x扩展和z扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；
+ 容易扩大开发团队，可以针对每个服务（service）组件开发团队；
+ 提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；
+ 系统不会被长期限制在某个技术栈上。

### 微服务的缺点：

>《人月神话》中讲到：没有银弹，意思是只靠一把锤子是盖不起摩天大楼的，要根据业务场景选择设计思路和实现工具。我们看下为了换回上面提到的好处，我们付出（trade）了什么？
+ 开发人员要处理分布式系统的复杂性；开发人员要设计服务之间的通信机制，对于需要多个后端服务的user case，要在没有分布式事务的情况下实现代码非常困难；涉及多个服务直接的自动化测试也具备相当的挑战性；
+ 服务管理的复杂性，在生产环境中要管理多个不同的服务的实例，这意味着开发团队需要全局统筹（PS：现在docker的出现适合解决这个问题）
+ 商业交易中同时给多个业务分主体更新消息很普遍。这种交易对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库。使用分布式交易并不一定是好的选择，不仅仅是因为CAP理论，还因为今天高扩展性的NoSQL数据库和消息传递中间件并不支持这一需求。最终你不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。

### 微服务的实施要点:
>+ 自动化文化与环境：自动构建、自动测试、自动部署。
+ 围绕业务能力建模服务，松耦合、高内聚、暴露接口而隐藏实现细节。
+ 服务协作模型：中心化（乐队模型：中心指挥）和去中心化（舞蹈模型：群舞自组织），各自场景不同。
+ 服务交互方式：RPC/REST/WS 技术很多但考虑统一。
+ 服务部署的独立性、失败隔离性、可监控性。
+ 服务流控：降级、限流
+ 服务恢复：多考虑故障发生如何快速恢复而非如何避免发生故障。
+ 服务发布：灰度。
+ 服务部署：一服务一主机模型，需要虚拟化(Hypervisor)、容器化(LXC, Docker)等技术支持，实现硬件资源隔离。
+ 服务配置：中心化配置服务支持
+ 康威定律：任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。系统架构的设计符合组织沟通结构取得的收益最大。
+ 伯斯塔尔法则：服务健壮性原则 —— 发送时要保守，接收时要开放。

## 结论
>随着云的出现计算世界已经永远地改变了，云为开发人员提供了迅速、便宜、而且几乎无限尺度地访问基础设施的能力。云的敏捷性与现代企业对高可用性和灵活性的要求使得单体架构变得差强人意，导致了基于微服务应用的兴起。有了一个全面的微服务平台，开发人员可以创建具有高性能、高可用性、成本效益以及独立生命周期管理的应用，支持高扩展性，横跨公有云和私有云。微服务是由云助力的一场应用革命。
